#**第一章 概述**#

不管是计算机的心脏—CPU，还是记忆的载体—内存，甚至于种类繁多的外围设备—磁盘、打印机、键盘、网卡等输入输出设备，它们之所以能有条不紊地协同工作，是因为有一层软件不遗余力地管理着它们。这层软件就是操作系统。

操作系统作是一种庞大而复杂的系统软件，为了对这样一个庞然大物有全方位的认识，让我们站在这座大厦的不同侧面给予初步观察。

##**1.1  认识操作系统**
从使用者的角度看，操作系统使得计算机易于使用。从程序员的角度看，操作系统把软件开发人员从与硬件打交道的繁琐事务中解放出来。从设计者的角度看，有了操作系统，就可以方便的对计算机系统中的各种软硬件资源进行有效的管理。

###**1.1.1 从使用者角度看**

我们对操作系统的认识一般是从使用开始的。打开计算机，呈现在眼前的首先是操作系统。如果用户打开的是操作系统字符界面，就可以通过命令完成需要的操作，例如在Linux下拷贝一个文件

`cp  /home/TEST  /mydir/test`

上述命令可以把/home目录下的TEST文件拷贝到mydir目录下，并更名为test。

为什么我们可以这么轻而易举地拷贝文件？操作系统从中做了什么？首先，文件这个概念是从操作系统中衍生出来的。如果没有文件这个实体，我们就必须指明数据存放的物理位置，例如，哪个柱面，哪个扇区。其次，数据搬动过程是复杂的I/O操作，一般用户无法关注这些具体的细节。最后，这个命令的执行还涉及其他复杂的操作，但是，有了操作系统，用户只需要知道文件名，其它繁琐的事务完全由操作系统去处理。

如果用户在图形界面下操作，上述处理就更加容易，只需点击鼠标就可以完成需要的操作。实际上，图形界面的本质也是执行各种命令，例如，如果是拷贝一个文件，那么就要调用cp命令，而具体的拷贝操作最终还是由操作系统去完成。

因此，不管是敲击键盘或者是点击鼠标，这些简单的操作指挥计算机完成着复杂的处理过程。正是操作系统，把繁琐留给自己，简单留给用户。

###**1.1.2 从程序开发者的角度看**

 从程序开发者的角度看，开发者不用关心如何在内存存放变量、数据，如何从外存存取数据，如何把数据在输出设备上显示出来等等。例如在Linux下实现cp命令的C语言片段为：

    inf=open(“/home/TEST”,O_RDONLY);
    out=open(“/mydir/test”,O_WRONLY);
    do{
       len=read(inf,buf,4096);
       write(outf,buf,len);
       } while(len);
         close(outf);
         close(inf);

在这段程序中，涉及到四个函数open(), close(),write()和read()，这些都是C语言函数库中的函数。进一步追究，这些函数都要涉及I/O操作，因此，它们的实现必须调用操作系统所提供的接口，也就是说，打开文件、关闭文件、读写文件的具体实现是由操作系统完成的。这些操作非常繁琐，操作系统不同，其具体实现可能不同。

###**1.1.3 从操作系统在整个计算机系统所处位置看**
如果把操作系统放在整个计算机系统中看，则如图1.1所示：

![](http://i.imgur.com/YbpnIM0.png)

因为操作系统这个术语越来越大众化，因此许多用户把他们在显示器屏幕上看到的东西理所当然的认为就是操作系统，例如认为图形界面、浏览器、系统工具集等都算操作系统的一部分。但是，本书讨论的操作系统是指内核（Kernel）。用户界面是操作系统的外在表象，内核是操作系统的内在核心，它真正完成用户程序所要求的操作。

从图1.1可以看出，**一方面操作系统是上层软件与硬件打交道的窗口和桥梁，另一方面操作系统是其它所有用户程序运行的基础。**

下面从一个程序的执行过程，我们看一下操作系统起什么样的作用。一个简单的C程序如下，其名为**test.c**：

    #include<stdio.h>
    main()
    {
      printf(“ Hello world\n”);
      return 0;
     }
用户对这个程序编译并连接:

    gcc test.c –o test

于是形成一个可执行的二进制文件test，在Linux 下执行该程序./test

执行过程简述如下:

1.	用户告诉操作系统执行test
2.	操作系统通过文件名在磁盘找到该程序
3.	检查可执行代码首部，找出代码和数据存放的地址
4.	文件系统找到第一个磁盘块
5.	操作系统建立程序的执行环境
6.	操作系统把程序从磁盘装入内存，并跳到程序开始处执行
7.	操作系统检查字符串的位置是否正确
8.	操作系统找到字符串被送往的设备
9.	操作系统将字符串送往输出设备窗口系统确定这是一个合法的操作，然后将字符串转换成像素
10.	窗口系统将像素写入存储映像区
11.	视频硬件将像素表示转换成一组模拟信号控制显示器（重画屏幕）
12.	显示器发射电子束。你在屏幕上看到Hello world。

从这个简单的例子可以看出，任何一个程序的运行只有借助于操作系统才能得以顺利完成，因此，从本质上说,**操作系统是应用程序的运行环境。**
 
###**1.1.4 从操作系统设计者的角度看**

操作系统是一个庞大复杂的系统软件。其设计目标有两个，一是尽可能地方便用户使用计算机，二是让各种软件资源和硬件资源高效而协调地运转起来。

笼统地说，计算机的硬件资源包括CPU、存储器和各种外设，其中外设种类繁多，如磁盘、鼠标、网络接口、打印机等，操作系统对外设的操作是通过I/O接口进行的。软件资源主要指存放在存储介质上的文件。

假设在一台计算机上有三道程序同时运行，并试图在一台打印机上输出运算结果，这意味着必须考虑以下问题：

（1）三道程序在内存中如何存放？

（2）什么时候让某个程序占用CPU？

（3）怎样有序地输出各个程序的运算结果？

对这些问题的解决都必须求助于操作系统，也就是说操作系统必须对内存进行管理，对CPU进行管理，对外设进行管理，对存放在磁盘上的文件更是要精心组织和管理，不仅如此，操作系统对这些资源进行管理的基础上，还要给用户提供良好的接口，以便用户能在某种程度上使用或者操纵这些资源。

因此，从操作系统设计者的角度考虑，一个操作系统必须包含以下几部分：

1)	操作系统接口

2)	CPU管理

3)	内存管理

4)	设备管理

5)	文件管理

以上这几大管理功能，因具体操作系统不同而稍有取舍，但Linux具备了以上所有的管理功能。

###**1.1.5  操作系统组成**

尽管我们从不同角度初步认识了操作系统这一概念，但日常应用中，操作系统一词已经有很多不同的内涵。操作系统通常被认为是整个系统中负责完成最基本功能和系统管理的部分。除了内核，这些部分还应当包括启动引导程序、命令行shell或者其他种类的用户界面、基本的文件管理工具和系统工具等。

可是，由于大多数最终用户是通过商业途径得到操作系统，他们很少会仅仅购买一个只包含以上功能的软件包。一般地，他们在得到操作系统的同时，更需要的是构架于其上的应用软件，从而完成所需的实际功能。为了满足这种需求，操作系统一般要和应用软件绑定发行和出售。这样的软件包在Linux领域被称作发布版。

由此就引起了一些误解，许多用户理所当然地认为发布版就是操作系统。但是，从逻辑结构划分，发布版中的很多应用软件不应该属于操作系统。

为了符合大多数人的习惯，在本书中，我们一般用操作系统这个词指代发布版，而用内核表示操作系统本来的逻辑概念。在不引起混淆的情况下，有时也会用操作系统表示内核。

操作系统本质上也是大型软件包（从开发者的角度看），因此结构组织也不会与其它大型软件迥然而异：操作系统的设计采取分层结构，越向上层抽象程度越高，越接近用户；相反，越向下层，越靠近硬件，抽象也相对接近硬件。另外，上层软件依靠下层软件提供的服务，而且上层软件本身还提供附加服务，因此，操作系统的结构总体呈现倒金子塔形。

不同的操作系统，其组成结构不尽相同。我们选取Unix/Linux操作系统作为背景,至于各种操作系统之间的具体差异，读者可以对比下面的公式之后形成自己的认识。
    
我们用一组简单的公式来描述操作系统的组成要素：

操作系统 = 内核 + 系统程序

系统程序 = 编译环境 ＋ API（应用程序接口）+AUI（用户接口）

编译环境 ＝ 编译程序 ＋ 连接程序 ＋ 装载程序

API  = 系统调用 ＋ 语言库函数（C、C++、Java等等）

AUI  =  shell + 系统服务例程（如x服务器等）+ 应用程序(浏览器，字处理，编辑器等) 

而整个软件系统是：

软件系统 = 操作系统 + AUI

操作系统最底层的组件是内核，其上层搭建了许多系统程序。

系统程序包括三个部分，分别是：编译环境、应用程序接口和用户接口。

编译环境包含汇编、C 等低高级语言编译程序，连接程序和装载程序，这些程序负责将文本格式的程序语言转变为机器能识别和装载的机器代码。

应用程序接口（API）包含内核提供的系统调用接口和语言库，系统调用是为了能让应用程序使用内核提供的服务，语言库函数则是为了方便应用程序开发，所以将一些常用的基础功能预先编译以供使用，比如对C语言来说有常用的C库等；

用户接口(AUI)包括我们熟悉的shell、系统服务程序和常用的应用程序。

这是一个典型的结构，但不是一成不变。许多操作系统的发行版中会有所删减，比如应用于嵌入式设备的系统，对X服务器就可能不做要求。但是像内核、系统调用等要素是必不可少的。

关于系统软件在此给予进一步说明。系统软件是相对应用软件而言的，应用软件针对最终用户需求编写，完成实际功能，而系统软件则是为了简化应用程序的开发而存在的，比如数据库系统为应用软件提供了有效的数据传输、存储服务；还有编程语言的执行环境（它由C库实现），也属于一种系统程序，它为应用程序开发提供了诸如I/O操作例程，图形库，计算库等等基础服务。可见系统软件范围覆盖很广，只要面向的服务群体不是最终用户的软件都可以划归到系统软件中。

##**1.2 开放源代码的Unix/Linux操作系统**

在操作系统的历史上，Unix的生存周期最长。从Unix年诞生以来，虽然已经使用了40多年，但仍然是现有操作系统中最强大和优秀的系统之一。
 
###**1.2.1 Unix诞生和发展**

1965年在美国国防部高级研究计划署ARPA的支持下，麻省理工学院、贝尔实验室和通用电气公司决定开发一种“公用计算服务系统”， 希望能够同时支持整个波士顿所有的分时用户。该系统称作**MULTICS (MULTiplexed Information and Computing Service )。**

MULTICS设计目标是通过电话线把远程终端接入计算机主机。但是，MULTICS研制难度超出了所有人预料。长期研制工作达不到预期目标，1969年4月贝尔实验室退出，通用电气公司也退出了。 但最终，经过多年的努力，MULTICS 成功地应用了。运行MULTICS的计算机系统在九十年代中陆续被关闭。

MULTICS引入了许多现代操作系统领域的概念雏形，对随后操作系统特别是Unix的成功有着巨大的影响。

1969年,贝尔退出MULTICS研制项目后, Ken Thompson和Dennis M. Ritchie两个研究人员想申请经费购买计算机从事操作系统研究，但多次申请得不到批准。项目无着落，他们边在一台无人用的PDP-7上重新摆弄原先在 MULTICS 项目上设计的“空间旅行”游戏。为了使游戏能够在PDP-7上顺利运行,他们陆续开发了浮点运算软件包、显示驱动软件，设计了文件系统、实用程序、shell 和汇编程序。 1970年, 在一切完成后, 给新系统起了个同 MULTICS发音相近的名字Unix。随后, Unix用C语言全部重写, 自此, Unix诞生了。

Unix是现代操作系统的代表。Unix运行时的安全性、可靠性以及强大的计算能力赢得广大用户的信赖。促使Unix系统成功的因素有三点， 首先, 由于Unix是用C语言编写, 因此它是可移植的，它可以运行在笔记本计算机、PC机、工作站直至巨型机上；第二, 系统源代码非常有效, 系统容易适应特殊的需求。最后, 也是最重要的一点, 它是一个良好的、通用的、多用户、多任务、分时操作系统。

尽管Unix已经不再是一个实验室项目了，但它仍然伴随着操作系统设计技术的进步而继续成长，人们仍然可以把它作为一个通用的操作系统用于研究和演练。不过，因为Unix最终变为一个商业操作系统，只有那些能负担得起许可费的企业才用得起，这限制了它的应用范围。Linux的出现完全改变了这种局面。

###**1.2.2 Linux诞生**

Linux的第一个版本诞生于1991年，它的作者就是Linus Torvalds，这个芬兰小伙最初在做一个调度系统的作业时，福至心灵，他突发灵感开始着手将其改造为一个实用的操作系统。在开发初期，他借助了最负盛名的教育类操作系统Minix的一些思想和成果，但他有自己的雄心，要把自己这个系统变得比Minix更实用、更强健。他决定把自己的系统代码公布于众，并且欢迎任何人来帮助修改和扩充Linux系统，Linux选择了备受推崇的Unix系统接口标准（POSIX标准），由此Linux成为Unix风格操作系统家族中的一员，而且是一个代码完全公开的操作系统。

Linux的生命力来自于它的开源思想，自Linus公开Linux代码以来，世界各地的软件工程师和爱好者不断积极地对Linux系统进行修改和加强，将其版本从0.1 提高到2.0 、2.2、2.4、2.6，一直到如今的3.0，同时Linux也被从初期的x86平台移植到了PowerPC、Arm，Sparc、MIPS、68K等几乎市面上能找到的所有体系结构上，尤其是建立在Linux之上的Android系统，大大加强了Linux系统的实用性。

Linux作为开源软件皇冠上的明珠，越来越受到欢迎，毫无疑问地成为人气最旺，最活跃的GNU项目，围绕Linux社区内各种组织雨后春笋般地出现，Linux必将在教育领域、在工业领域取得更大的成功。

###**1.2.3操作系统标准POSIX**

POSIX 表示可移植操作系统接口（Portable Operating System Interface）。该标准由IEEE制订，并由国际标准化组织接受为国际标准。POSIX是在Unix标准化过程中出现的产物。到目前为止，POSIX已成为一个涵盖范围很广的标准体系，己经颁布了20多个相关标准，其中POSIX 1003.1标准定义了一个最小的Unix操作系统接口。也就是说，1003.1标准给出了一组函数的定义，至于如何实现，标准并不关注；或者说POSIX 1003.1提供了一种机制，而具体的策略由实现者决定。

任何操作系统只有符合POSIX 1003.1这一标准，就可以运行Unix程序。Linux在设计时遵循这一标准，因此，凡是在Unix上运行的应用程序几乎都可以在Linux上运行，这也是Linux得以流行的原因之一。

###**1.2.4 GNU 和 Linux**

GNU 是 GNU Is Not Unix 的递归缩写，是自由软件基金会的一个项目，该项目的目标是开发一个自由的 Unix 版本，这一 Unix 版本称为 HURD。尽管 HURD 尚未完成，但 GNU 项目已经开发了许多高质量的编程工具，包括 emacs 编辑器、著名的 GNU C 和 C++ 编译器（gcc 和 g++），这些编译器可以在任何计算机系统上运行。所有的 GNU 软件和派生工作均适用 GNU 通用公共许可证，即 GPL。GPL 允许软件作者拥有软件版权，但授予其他任何人以合法复制、发行和修改软件的权利。

 Linux 的开发使用了许多 GNU 工具。Linux 系统上用于实现 POSIX.2 标准的工具几乎都是 GNU 项目开发的，Linux 内核、GNU 工具以及其他一些自由软件组成了人们常说的 Linux系统或Linux发布版：
 
1.	符合 POSIX 标准的操作系统内核、 Shell 和外围工具。 
2.	C 语言编译器和其他开发工具及函数库。
3.	X Window 窗口系统。 
4.	各种应用软件，包括字处理软件、图象处理软件等。 
5.	其他各种 Internet 软件，包括 FTP 服务器、WWW 服务器等。 
6.	关系数据库管理系统等。
 
###**1.2.5 Linux的开发模式**

Linux是一大批广泛分布于世界各地的软件爱好者，以互联网为纽带，通过BBS、新闻组及电子邮件等现代通信方式，同时参与的软件开发项目。Linux的开发模式是开放与协作的，在设计上融合了各方面的优点，也经历了各种各样的测试与考验。它具有一下特点：

- 开放与协作的开发模式。提供源代码，遵守GPL。	
- 发挥集体智慧，减少重复劳动。
- 经历了各种各样的测试与考验，软件的稳定性好。	
- 开发人员凭兴趣去开发，热情高，具有创造性。
 
##**1.3 Linux内核**


Linux内核指的是在Linus领导下的开发小组开发出的系统内核，它是所有Linux 发布版本的核心。Linux内核软件开发人员一般在百人以上，任何自由程序员都可以提交自己的修改工作，但是只有领导者Linus和Alan Cox才能够将这些工作合并到正式的核心发布版本中。他们一般采用邮件列表来进行项目管理、交流、错误报告。其好处是软件更新速度和发展速度快，计划的开放性好。由于有大量的用户进行测试，而最终裁决人只有少数非常有经验的程序员，因此正式发布的代码质量高。

###**1.3.1 Linux 内核的技术特点**

Linux是一种是实用性很强的现代操作系统。开发它的中坚力量是经验丰富的软件工程师，他们 多以实用性和效率为出发点，同时还考虑了工业规范和兼容性等因素，因此不同于教学性操作系统单纯追求理论上的先进性，Linux系统内核兼具实用性和高效性。其特色如下：

1) Linux内核被设计成单内核（monolithic）结构，这是相对微内核而言的。所谓单内核就是从整体上把内核作为一个大过程来实现，而进程管理、内存管理等是其中的一个个模块，模块之间可以直接调用相关的函数。微内核是一种功能更贴近硬件的核心软件，它一般仅仅包括基本的内存管理、同步原语、进程间通讯机制、I/O操作和中断管理，这样做有利于提高可扩展性和可移植性。但是微内核与诸如文件管理、设备驱动、虚拟内存管理、进程管理等其它上层模块之间需要有较高的通讯开销，所以目前多集中在理论教学领域，对工业应用来说，效率难以保证 ，因此单内核的Linux效率高，紧凑性强。

2) 2.6版本前的Linux内核是单线程结构——所谓单线程结构是说同一时间只允许有一个执行线程（内核中函数独立执行）在内核中运行 ，不会被调度程序打断而运行其它任务，这种内核称为非抢占式的，它的好处在于内核中没有并发任务（单处理器而言），因此避免了许多复杂的同步问题，但其不利影响是非抢占特性延迟了系统响应速度，新任务必须等待当前任务在内核执行完毕并自动退出后才能获得运行机会。然而，工业控制领域需要高响应速度，由于Robert love等人的贡献，2.6版本将抢占技术引入了Linux内核，使其变为可以进行内核抢占的操作系统 ——当然，付出的代价是同步变得更复杂。

3)Linux内核支持动态加载内核模块。为了保证能方便地支持新设备、新功能，又不会无限地扩大内核规模，Linux系统对设备驱动或新文件系统等采用了模块化的方式，用户在需要时可以现场动态加载，使用完毕可以动态卸载。同时对内核，用户也可以定制，选择适合自己的功能，将不需要的部分剔除出内核。这些都保证了内核的紧凑、可扩展性好。

4) Linux内核被动地提供服务。所谓被动是因为它为用户服务的唯一方式是通过系统调用来请求在内核空间执行某种任务。内核本身是一种函数和数据结构的集合，不存在运行着的内核进程为用户提供服务 

5) Linux内核采用了虚拟内存技术，使得内存空间达到4GB 。其中0-3G属于用户空间，称为用户段，3G-4G属于内核空间，称为内核段。这样，应用程序就可以使用远远大于实际物理内存的存储空间了。

6) Linux的文件系统实现了一种抽象文件模型——虚拟文件系统（Virtual Filesystem Switch,VFS），该文件系统属于Unix风格。VFS是Linux的特色之一。通过使用虚拟文件系统，内核屏蔽了各种不同文件系统的内在差别，使得用户可以通过统一的界面访问各种不同格式的文件系统。

7) Linux提供了一套很有效的延迟执行机制——下半部分、软中断、tasklet和2.6新引入的工作队列等，这些技术保证了系统可以针对任务的轻重缓急，更细粒度地选择执行时机。

Linux内核的以上特点，在后续的章节中会逐步体现出来。

###**1.3.2 Linux内核的位置**

Linux内核不是孤立的，必须把它放在整个Linux系统中去研究，图1.2显示了Linux内核在整个系统中的位置：
![](http://i.imgur.com/ABWq00T.png)


由图1.2可以看出，整个系统由四个部分组成：

1.	用户进程—用户应用程序是运行在Linux内核之上的一个庞大的软件集合， 当一个用户程序在操作系统之上运行时，它成为操作系统中的一个进程。关于进程更详细的描述参见第三章。
2.	系统调用接口— 在应用程序中，可通过系统调用来调用操作系统内核中特定的过程，以实现特定的服务。例如，在程序中有一条读取数据的read()系统调用，但是，真正的读取操作是由操作系统内核完成的。所以说，系统调用是内核代码的一部分，更详细内容参看第六章。
3.	Linux内核—内核是操作系统的灵魂，它负责管理内存、磁盘上的文件，负责启动并运行程序，负责从网络上接收和发送数据包等等。内核是本书讨论的重点。
4.	硬件—这个子系统包括了Linux安装时需要的所有可能的物理设备。例如，CPU、 内存、硬盘、网络硬件等等。

###**1.3.3 Linux内核体系结构**

 虽然Linux内核和Unix系统在具体实现上有很大不同，但是其结构还基本保持一致，Linux内核除系统调调用外，由5个主要的子系统组成，如图1.3
![](http://i.imgur.com/BZY6Wzx.png)  

1.	**进程调度(Process Scheduler，SCHED)**－控制着进程对CPU的访问。当需要选择一个进程运行时，由调度程序选择最值得运行的进程。
2.	**内存管理(Memory Manager，MM)**－允许多个进程安全地共享主内存区域 。Linux的内存管理支持虚拟内存，即在计算机中运行的程序，其代码、数据和堆栈的总量可以超过实际内存的大小，操作系统只将当前使用的程序块保留在内存中，其余的程序块则保留在磁盘上。必要时，操作系统负责在磁盘和内存之间交换程序块。
因为虚拟内存管理需要硬件支持，因此内存管理从逻辑上可以分为硬件无关的部分和硬件相关的部分。详细内容参看第二章和第四章。
3.	**虚拟文件系统(VFS)**－隐藏各种不同硬件的具体细节，为所有设备提供统一的接口。虚拟文件系统支持多达数十种不同的文件系统，这也是Linux较有特色的一部分。
虚拟文件系统可分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2/ext3, ntfs等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。详细内容参看第八章和第九章。
4.	**网络接口(Network Interface，NET)**－提供了对各种网络标准协议的存取和各种网络硬件的支持。网络子系统可分为网络协议和网络驱动程序两部分。网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备进行通信，每一种可能的硬件设备都有相应的设备驱动程序。因为这部分内容相对独立和复杂，本书不做详细介绍。
5.	**进程间通信(Inter-Process Communication，IPC)**－ 支持进程间各种通信机制，包括共享内存、消息队列及管道等。这部分内容也相对独立，本书不做详细介绍。

从图1.3可以看出，处于中心位置的是进程调度，所有其它的子系统都依赖于它，因为每个子系统都需要挂起或恢复进程。一般情况下，当一个进程等待硬件操作完成时，它被挂起；当操作真正完成时，进程恢复执行。例如，当一个进程通过网络发送一条消息时，发送进程被挂起，一直到硬件成功地完成消息的发送。其它子系统(内存管理，虚拟文件系统及进程间通信)以相似的理由依赖于进程调度。

##**1.4 Linux内核源代码**

   在Linux内核官方网站[http://www.kernel.org](http://www.kernel.org)，可以随时获取不同版本的Linux源代码。为了深入地了解 Linux的实现机制，有必要阅读Linux的源代码。

###**1.4.2 Linux内核版本**

Linux内核版本从最初的0.01到目前的3.0.x不断发生着变化。Linux的内核具有两种不同的版本号，即实验版本和产品化版本。这种机制使用三个或者四个用“.”分隔的数字来代表不同内核版本。第一个数字是主版本号，第二个数字是从版本号，第三个数字是修订版本号。第四个可选的数字为稳定版本号。从版本号可以反映出该内核是一个产品化版本还是一个处于开发中的实验版本:该数字如果是偶数，那么此内核就是产品化版，如果是奇数，那么它就是实验版。举例来说，版本号为2.6.30.1的内核，它就是一个产品化版。这个内核的主板本号是2，从版本号是6，修订版本号是30，稳定版本号是1。头两个数字在一起描述了“内核系列”—在这个例子中，就是2.6版内核系列。

Linux的两种版本是相互关联的。实验版本最初是产品化版本的拷贝,然后产品化版本只修改错误，实验版本继续增加新功能，到实验版本测试证明稳定后拷贝成新的产品化版本，不断循环。如图1.4所示：

![](http://i.imgur.com/CenH9Xo.png)

这样的组织方式一方面可以方便软件开发人员加入到Linux的开发和测试中来，另一方面又可以让一些用户使用稳定的Linux版本。目前，比较稳定的内核版本是2.6.x，最新版本为3.0.x。

###**1.4.3 Linux内核源代码的结构**

Linux内核源代码位于`/usr/src/linux`目录下，其主要目录结构分布如图1.5所示，
![](http://i.imgur.com/5Rfd2wS.png)

     
下面对每一个目录给予简单描述。

**- include/**子目录包含了建立内核代码时所需的大部分包含文件。

**- init/** 子目录包含了内核的初始化代码，这是内核开始工作的起点。

**- arch/**子目录包含了Linux支持的所有硬件结构的内核代码，如图1.5，

**- arch/**子目录下有x86、ARM和alpha等针对不同体系结构的代码。

**- drivers/** 目录包含了内核中所有的设备驱动程序，如字符设备，块设备，scsi 设备驱动程序等。

**- fs/** 目录包含了所有文件系统的代码，如ext3/ext4, ntfs模块的代码等等。
  

**- net/** 目录包含了内核中关于网络的代码。
 
**- mm/** 目录包含了所有的内存管理代码。
 
**- ipc/** 目录包含了进程间通信的代码。

**- kernel/**  目录包含了主内核代码

###**1.4.4 Linux内核源代码分析工具**

Linux的内核组织结构虽然非常有条理，但是，它毕竟是众人合作的结果，在阅读代码的时候要将各个部分结合起来，确实是件非常困难的事情。因为在内核中的代码层次结构肯定分多个层次，那么对一个函数的分析，肯定会涉及到多个函数，而每一个函数可能又有多层的调用，一层层下来，直接在代码文件中查找那些函数会让你失去耐心和兴趣。

俗话说：“工欲善其事，必先利其器”。面对Linux这样庞大的源代码，必须有相应工具的支持才能使分析有效地进行下去。 在此介绍两种源代码的分析工具，希望能对感兴趣的读者有所帮助。
 
**1． Linux超文本交叉代码检索工具**

Linux超文本交叉代码检索工具LXR（Linux Cross Reference），是由挪威奥斯陆大学数学系Arne Georg Gleditsch和Per Kristian Gjermshus编写的。这个工具实际上运行在Linux或者Unix平台下，通过对源代码中的所有符号建立索引，从而可以方便的检索任何一个符号，包括函数、外部变量、文件名、宏定义等等。不仅仅是针对Linux源代码，对于C语言的其他大型的项目，都可以建立其lxr站点，以提供开发者查询代码，以及后继开发者学习代码。 

目前的lxr是专门为Linux下面的Apache服务器设计的，通过运行perl脚本，检索源代码索引文件，将数据发送到网络客户端的Web浏览器上。任何一种平台上的Web浏览器都可以访问，这就方便了习惯在Windows平台下工作的用户。 关于lxr的英文网站为[http://lxr.linux.no/](http://lxr.linux.no/)。

**2．Windows平台下的源代码阅读工具Source Insight**

为了方便地学习Linux源程序，我们不妨回到我们熟悉的window环境下。但是在Window平台上，使用一些常见的集成开发环境，效果也不是很理想，比如难以将所有的文件加进去，查找速度缓慢，对于非Windows平台的函数不能彩色显示。在Windows平台下有一个强大的源代码编辑器，它的卓越性能使得学习Linux内核源代码的难度大大降低，这便是Source Insight，它是一个Windows平台下的共享软件，可以从[http://www.sourceinsight.com/](http://www.sourceinsight.com/)上下载试用版本。由于Source Insight是一个Windows平台的应用软件，所以首先要通过相应手段把Linux系统上的程序源代码移到Windows平台下，这一点可以通过在Linux下将/usr/src目录下的文件拷贝到Windows的分区上，或者从网上或光盘直接拷贝文件到Windows的分区。
   
##**1.5 Linux内核模块编程入门**

内核模块是Linux内核向外部提供的一个插口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM），我们简称为模块。Linux内核之所以提供模块机制，是因为它本身是一个单内核（monolithic kernel）。单内核的最大优点是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。

###**1.5.1	什么是模块**

模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。

###**1.5.2	编写一个简单的模块**

模块和内核都在内核空间运行，模块编程在一定意义上说就是内核编程。因为内核版本的每次变化，其中的某些函数名也会相应地发生变化，因此模块编程与内核版本密切相关。我们在本书中所涉及的内核编程，基于的内核为2.6.x，对于其他版本，还需要做一些适当调整。

**1．程序举例**

      #include <linux/module.h>
      #include <linux/kernel.h>
      #include <linux/init.h>

      static int __init lkp_init( void )
    {  
     printk("<1>Hello,World! from the kernel space...\n");  
     return 0;
    } 

    static void __exit lkp_cleanup( void )
    {  
     printk("<1>Goodbye, World! leaving kernel space...\n");  } 
     module_init(lkp_init);
     module_exit(lkp_cleanup);
     MODULE_LICENSE("GPL");

**2．说明**

（1）	module.h头文件中包含了对模块的结构定义以及模块的版本控制，任何模块程序的编写都要包含这个头文件; 头文件kernel.h包含了常用的内核函数；而头文件init.h包含了宏\_init和\_exit，宏_init告诉编译程序相关的函数和变量仅用于初始化，编译程序将标有 _init的所有代码存储到特殊的内存段中，初始化结束后就释放这段内存。

（2）	函数lkp\_init ()是模块的初始化函数，函数lkp\_cleanup ()是模块的退出和清理函数。

（3）	我们在这里使用了printk()函数，该函数是由内核定义的，功能与C库中的printf()类似，它把要打印的信息输出到终端或系统日志。字符串中的<1>是输出的级别，表示立即在终端输出。

（4）	 函数module\_init()和cleanup\_exit()是模块编程中最基本也是必须的两个函数。module\_init()向内核注册模块所提供的新功能，而cleanup_exit()注销由模块提供的所有功能。

（5）	最后一句告诉内核该模块具有GNU公共许可证。

**3．编译模块**

假定我们给前面的程序起名为“hellomod.c”，只有超级用户才能加载和卸载模块。对于2.6内核的模块，其Makefile文件的基本内容如下：

     # Makefile2.6
     obj-m += hellomod.o        # 产生hellomod 模块的目标文件
     CURRENT_PATH := $(shell pwd)   #模块所在的当前路径
     LINUX_KERNEL := $(shell uname -r)    #Linux内核源代码的当前版本
     LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL) #Linux内核源代码的绝对路径
    all:
      make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules   #编译模块
    clean:
      make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean    #清理
  
上面的Makefile中使用了 obj-m := 这个赋值语句，其含义说明要使用目标文件hellomod.o建立一个模块，最后生成的模块名是helloworld.ko，如果你有一个名为module.ko的模块依赖于两个文件 file1.o和file2.o，那么我们可以使用module-obj扩展，如下所示
 
    obj-m := module.o 
    module-objs := file1.o file2.o

关于Makefile的具体编写方法，请参考相关书籍。

最后，用make命令运行Makefile

**4.运行代码**  
当编译好模块，我们就可以将新的模块插入到内核中，这可以用insmod命令来实现，如下所示：

    insmod hellomod.ko

然后，可以用lsmod命令检查模块是否正确插入到内核中了：

模块的输出由printk（）来产生。该函数默认打印系统文件/var/log/messages的内容。快速浏览这些消息可输入如下命令：

    tail /var/log/messages

这一命令打印日志文件的最后10行内容，可以看到我们的初始化信息：.
...

    Mar  6 10:35:55  lkp1  kernel: Hello,World! from the kernel space...

使用rmmod命令，加上我们在insmod中看到的模块名，可以从内核中移除该模块（还可以看到退出时显示的信息）。如下所示：

    rmmod hellomod

同样，输出的内容也在日志文件中，如下所示：

    ......
    Mar  6 12:00:05  lkp1  kernel: Hello,World! from the kernel space...

###**2.6.3应用程序与内核模块的比较**

模块编程属于内核编程，因此，除了对内核相关知识有所了解外，还需要了解与模块相关的知识。

为了加深对内核模块的了解，表1.3给出应用程序与内核模块程序的比较。

   **表1.3 应用程序与内核模块程序的比较**

| 		|C语言应用程序|内核模块程序|
|:------ | :------- |  :------|
|使用函数|Libc库|内核函数|
|运行空间|用户空间|内核空间|
|运行权限|普通用户|超级用户|
|入口函数|main（）|module_init|
|出口函数|exit（）|module_cleanup()|
|编译|gcc-c|mark|
|连接|gcc|insmod|
|运行|直接运行|insmod|
|调试|gdb|kdbug,kdb,kgdb等|


从表1.3我们可以看出，内核模块程序不能调用libc库中的函数，它运行在内核空间，且只有超级用户可以对其运行。另外，模块程序必须通过module()\_init和module()\_cleanup函数来告诉内核“我来了”和“我走了”。

在了解内核模块简单编程之后，下面通过对内核中常用数据结构链表的分析，使大家初步了解Linux内核的具体源代码，并编写内核模块对其加以应用。

##**1.7  Linux 内核中链表的实现及应用**

链表是Linux内核中最简单、最常用的一种数据结构。与数组相比，链表中可以动态插入或删除元素，在编译时不必知道要创建的元素个数。也因为链表中每个元素的创建时间各不相同，因此，它们在内存无需占用连续的内存单元，因为单元的不连续，因此各元素需要通过某种方式被链接在一起，于是，每个元素都包含一个指向下一个元素的指针，当有元素加入链表或者从链表中删除元素时，只需要调整下一个节点的指针就可以了。

###**1.7.1 链表的演化**

   在C 语言中，一个基本的双向链表定义如下：

    struct my_list{ 
	void *mydata; 
	struct my_list *next;
	struct my_list *prev;
	}; 

![](http://i.imgur.com/d3wmDTM.png)
   
图1.6是一双链表，通过前趋（prev）和后继（next）两个指针域，就可以从两个方向遍历双链表，这使得遍历链表的代价减少。如果打乱前驱、后继的依赖关系，就可以构成"二叉树"；如果再让首节点的前趋指向链表尾节点、尾节点的后继指向首节点（如图1.6中虚线部分），就构成了循环链表；如果设计更多的指针域，就可以构成各种复杂的树状数据结构。

如果减少一个指针域，就退化成单链表，如果只能对链表的首尾进行插入或删除操作，就演变为队结构，如果只能对链表的头进行插入或删除操作，就退化为栈结构。
  
###**1.7.2. 链表的定义和操作**

如上所述，在众多数据结构中，选取双向链表作为基本数据结构，并将其嵌入到其他数据结构中，从而可以演化出其他复杂数据结构。Linux内核实现方式与众不同，对链表给出了一种抽象的定义。

**1. 链表的定义**

    struct list_head {                     
    struct list_head *next, *prev;  
    };     
                                           
这个不含数据域的链表，可以嵌入到任何结构中，例如可以按如下方式定义含有数据域的链表： 

    struct my_list{ 
	void *mydata; 
	struct list_head list;
	};  
 
在此，进一步说明几点：

1） list域隐藏了链表的指针特性。

2）	 struct list_head可以位于结构的任何位置，可以给其起任何名字

3）	在一个结构中可以有多个list 域

以struct list_head为基本对象，对链表进行插入、删除、合并以及遍历等各种操作。

**2 链表的声明和初始化宏**

实际上， struct list_head只定义了链表节点，并没有专门定义链表头，那么一个链表结构是如何建立起来的？内核代码list.h中定义了两个宏：

    #define LIST_HEAD_INIT(name) { &(name), &(name) } /*仅初始化*/
    #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) /*声明并初始化*/

如果我们要申明并初始化自己的链表头mylist，则直接调用LIST_HEAD：

    LIST_HEAD(mylist_head)

调用之后，mylist\_head的next、prev指针都初始化为指向自己，这样，我们就有了一个空链表，如何判断链表是否为空，自己写一下这个简单的函数list_empty ，也就是让头指针的next指向自己。


**3 在链表中增加一个结点**

   list.h中增加节点的函数为：

     static inline void __list_add();
     static inline void list_add();
     static inline void list_add_tail();

 在内核代码中，函数名前加两个下划线表示内部函数，第一个函数的具体代码如下：

    static inline void __list_add(struct list_head *new,
              struct list_head *prev,
              struct list_head *next)
    {
      next->prev = new;
      new->next = next;
      new->prev = prev;
      prev->next = new;
    }

调用这个内部函数以分别在链表头和尾增加节点：

    static inline void list_add(struct list_head *new, struct list_head *head)
    {
    __list_add(new, head, head->next);
    }

该函数向指定链表的head节点后插入new节点。因为链表是循环的，而且通常没有首尾节点的概念，所以可以将任何节点传递给head。但是如果传递最后一个元素传给head，那么该函数可以用来实现一个栈。


    static inline void list_add_tail(struct list_head *new, struct list_head *head)
    {
    __list_add(new, head->prev, head);
    }


该函数向指定链表的head节点前插入new节点。和list_add()函数类似，因为链表是环形的，而且可以将任何节点传递给head。但是如果传递第一个元素给head那么，该函数可以用来实现一个队列。

另外，对函数名前面的staitic inline 关键字给予说明。“static”加在函数前，表示这个函数是静态函数，所谓静态函数，实际上是对函数作用域的限制，指该函数的作用域仅局限于本文件。所以说，static具有信息隐藏的作用。而关键字"inline“加在函数前，说明这个函数对编译程序是可见的，也就是说，编译程序在调用这个函数时就立即展开该函数。所以，关键字inline 必须与函数定义体放在一起才能使函数成为内联。inline函数一般放在头文件中。

关于节点的删除，将结合后面的例子给予具体说明。至于节点的搬移和合并，读者自行分析，在此不一一讨论，下面主要分析链表的遍历。


**4. 遍历链表**

 list.h中定义了如下遍历链表本的宏：

    #define list_for_each(pos, head) \
      for (pos = (head)->next; pos != (head); \
            pos = pos->next)  

这种遍历仅仅是找到一个个节点在链表中的偏移位置pos，如图1.7所示。

![](http://i.imgur.com/X4InkHq.png)

问题在于，如何通过pos获得节点的起始地址，从而可以引用节点中的域？ 于是 list.h中定义了晦涩难懂的list_entry（）宏：

    #define list_entry(ptr, type, member) \
    ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))


指针ptr指向结构体type中的成员member；通过指针ptr，返回结构体type的起始地址，也就是list_entry返回指向type类型的指针，如图1.8所示。

![](http://i.imgur.com/L6Bc8tu.png)

进一步仔细分析list_entry（）宏：

((unsigned long) &(type *)0)->member)把0地址转化为type结构的指针，然后获取该结构中member域的指针，也就是获得了member在type结构中的偏移量。其中(char *)(ptr)求出的是ptr的绝对地址，二者相减，于是得到type类型结构体的起始地址，如图1.9所示。

![](http://i.imgur.com/8NMNQjb.png)

 到此，我们对链表的实现机制有初步了解，更多的函数和实现查看[include/linux/list.h ](include/linux/list.h )中的代码。如何应用这些函数，下面举例说明。尽管list.h是内核代码中的头文件，但我们稍加修改后也可以把它移植到用户空间使用。

###**1.7.3 链表的应用**

 [linclude/linux/list.h](linclude/linux/list.h)中的函数和宏，是一组精心设计的接口，有比较完整的注释和清晰的思路，请详细阅读该文件中的代码。

下面编写一个linux 内核模块，用以创建、增加、删除和遍历一个双向链表。

    #include <linux/kernel.h>
    #include <linux/module.h>
    #include <linux/slab.h>
    #include <linux/list.h>

    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("XIYOU");

    #define N 10   //链表节点
    struct numlist {
	  int num;//数据
	  struct list_head list;//指向双联表前后节点的指针
    };

    struct numlist numhead;//头节点

    static int __init doublelist_init(void)
    {
	//初始化头节点
	struct numlist *listnode;//每次申请链表节点时所用的指针
	struct list_head *pos;
	struct numlist *p;
	int i;

	printk("doublelist is starting...\n");
	INIT_LIST_HEAD(&numhead.list);

	//建立N个节点，依次加入到链表当中
	for (i = 0; i < N; i++) {
		listnode = (struct numlist *)kmalloc(sizeof(struct numlist), GFP_KERNEL); // kmalloc（）在内核空间申请内存，类似于malloc,参见第四章
		listnode->num = i+1;
		list_add_tail(&listnode->list, &numhead.list);
		printk("Node %d has added to the doublelist...\n", i+1);
	}

	//遍历链表
	i = 1;
	list_for_each(pos, &numhead.list) {
		p = list_entry(pos, struct numlist, list);
		printk("Node %d's data:%d\n", i, p->num);
		i++;
	}
	
	return 0;
    }

    static void __exit doublelist_exit(void)
    {
	struct list_head *pos, *n;
	struct numlist *p;
	int i;
	
	//依次删除N个节点
	i = 1;
	list_for_each_safe(pos, n, &numhead.list) {  //为了安全删除节点而进行的遍历
		list_del(pos);//从双链表中删除当前节点
		p = list_entry(pos, struct numlist, list);//得到当前数据节点的首地址，即指针
		kfree(p);//释放该数据节点所占空间
		printk("Node %d has removed from the doublelist...\n", i++);
	}
	printk("doublelist is exiting..\n");
    }

    module_init(doublelist_init);
    module_exit(doublelist_exit);

说明： 关于删除元素的安全性问题

在上面的代码中，为什么不调用list\_for\_each（）宏而调用 list\_for\_each_safe（）进行删除前的遍历？具体看删除函数的源代码：

    static inline void __list_del(struct list_head * prev, struct list_head * next)
    {
        next->prev = prev;
        prev->next = next;
    }
    static inline void list_del(struct list_head *entry)
    {
        __list_del(entry->prev, entry->next);
        entry->next = LIST_POISON1;
        entry->prev = LIST_POISON2;
    }

可以看出，当执行删除操作的时候， 被删除的节点的两个指针被指向一个固定的位置（LIST\_POISON1和LIST\_POISON2是内核空间的两个地址）。而list\_for\_each(pos, head)中的pos指针在遍历过程中向后移动，即pos = pos->next，如果执行了list\_del()操作，pos将指向这个固定位置的next, prev,而此时的next, prev没有任何指向了，必然出错。

而list\_for\_each_safe(p, n, head) 宏解决了上面的问题：

     #define list_for_each_safe(pos, n, head) \
     for (pos = (head)->next, n = pos->next; pos != (head); \
      pos = n, n = pos->next)

  它采用了一个同pos同样类型的指针n 来暂存将要被删除的节点指针pos，从而使得删除操作不影响pos指针！ 

这里要说明的是，哈希表也是链表的一种衍生，在list.h中也有相关的代码，在此不仔细讨论，读者可自行分析。


   
小结

本章首先从不同侧面概要描述了大家熟悉而又陌生的操作系统，使读者从宏观上对操作系统有一个初步认识。之后，简要介绍了Linux的同族同源Unix，从而说明Linux赖以生存的土壤源于30多年Unix的发展。尽管Linux诞生于学生之手，但成长于Internet这片肥沃的土壤，壮大于自由而开放的文化。因为其土壤和文化背景的厚实，决定了其发展的持续性和广阔的前景。

为了让读者对Linux有初步了解后动手实践，本章还介绍了Linux内核中的模块编写方法，并以链表为入口点，让读者近距离感知Linux内核代码设计中的精彩和美妙。

**习题**

1.	通过阅读本章，谈谈自己对操作系统的认识。
2.	在操作系统的演变过程中，你认为起推动作用的是什么？
3.	从硬件的角度谈操作系统的发展，从中得到什么启发？
4.	从软件设计的角度谈操作系统的发展，从中得到什么启发？
5.	从Unix/Linux的诞生中，你受到什么启发？
6.	什么是Posix标准，为什么现代操作系统的设计必须遵循Posix标准？
7.	什么是GNU？Linux与GNU有什么关系？
8.	你认为Linux开发模式有何优缺点？
9.	Linux系统由哪些部分组成？Linux内核处于什么位置？
10.	Linux内核由哪几个子系统组成？各个子系统的主要功能是什么？
11.	访问http://www.kernel.org/，理解Linux的内核的版本树，了解最新内核的特点
12.	了解Linux内核源代码结构，访问源代码导航网站[http://lxr.linux.no/](http://lxr.linux.no/)，说明/kernel目录下包含哪些文件。   
13.	分析[include/linux/list.h](include/linux/list.h)中哈希表的实现，给出分析报告，并编写内核模块，调用其中的函数和宏，实现哈希表的建立和查找。


